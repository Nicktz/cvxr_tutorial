---
title: "The Structure of Atoms"
author: "Anqi Fu and Balasubramanian Narasimhan"
date: "6/9/2019"
slug: cvxr_atom-structure
categories: Developer Guide
---

```{r prereqs, message = FALSE, echo = FALSE}
library(CVXR)
```

## Function Properties
The quadratic-over-linear atom is defined as
$$
  f(x,y) := \frac{\|x\|_2^2}{y} \quad \mbox{with} \quad \mathbf{dom}\;f = \{(x,y) \in \mathbf{R}^n \times \mathbf{R}: y > 0\}.
$$

## Canonicalization
Once `CVXR` verifies a problem is DCP, it then converts that problem into a solver-compatible form. This *canonicalization* process is carried out through a series of calls to individual atom canonicalizers, defined in the reductions framework. To implement an atom, one must explicitly derive its canonicalizer for a particular class of problems (e.g., conic programs), which is supported by the desired solver. We show an approach below that uses its graph implementation.

A function $g: \mathbf{R}^n \rightarrow \mathbf{R}$ is convex if and only if its epigraph
$$
  \mathbf{epi}\;g = \{(x,t) \in \mathbf{R}^n \times \mathbf{R}: g(x) \leq t\}
$$
is a convex set. Then, it can be written as
$$
  g(x) = \inf \{t \in \mathbf{R}: (x,t) \in \mathbf{epi}\;g \}.
$$
A similar relationship exists between concave functions and their hypographs. The *graph implementation* of a function is a representation of its epigraph or hypograph as a disciplined convex feasibility problem. This provides an elegant means of defining a nondifferentiable function in terms of a canonical optimization problem, which can be directly evaluated by a solver.

For instance, the quadratic-over-linear atom can be written as a second-order cone program (SOCP). Given $(x,y) \in \mathbf{dom}\;f$, the inequality $f(x,y) \leq t$ is equivalent to
$$
\begin{align*}
  4\|x\|_2^2 &\leq 4ty = (y+t)^2 - (y-t)^2 \\
  (y-t)^2 + \|2x\|_2^2 &\leq (y+t)^2 \\
  \left\|\begin{pmatrix} y-t \\ 2x \end{pmatrix}\right\|_2 &\leq y+t
\end{align*}
$$
so that
$$
  f(x,y) = \inf \left\{t \in \mathbf{R}: \left(\begin{pmatrix} y-t \\ 2x \end{pmatrix}, y+t\right) \in \mathcal{K} \right\},
$$
where $\mathcal{K} := \{(u,v) \in \mathbf{R}^{n+1} \times \mathbf{R}: \|u\|_2 \leq v\}$ is a second-order cone. Thus, $f(x,y)$ is the solution to an SOCP, which may be evaluated using any conic solver. The canonicalizer for quadratic-over-linear takes as input $(x,y)$ and outputs the above SOCP.

In `CVXR`, this function is defined in dcp2cone.R, since it is used to reduce a DCP problem to a cone program.
```{r, eval=FALSE}
Dcp2Cone.quad_over_lin_canon <- function(expr, args) {
  # quad_over_lin := sum_{ij} X^2_{ij} / y
  x <- args[[1]]
  y <- flatten(args[[2]])
  
  # Pre-condition: dim = c()
  t <- Variable(1)
  
  # (y+t, y-t, 2*x) must lie in the second-order cone, where y+t is the scalar part
  # of the second-order cone constraint
  constraints <- list(SOC(t = y+t, X = VStack(y-t, 2*flatten(x)), axis = 2))
  return(list(t, constraints))
}
```
TODO: Describe what the code is doing.

## Putting It All Together
Suppose we are given $A \in \mathbf{R}^{m \times n}$ and $b \in \mathbf{R}^m$, and would like to solve
$$
  \begin{array}{ll}
    \mbox{minimize} & f(x,y) \\
    \mbox{subject to} & Ax = b
  \end{array}
$$
with respect to $x \in \mathbf{R}^n$ and $y \in \mathbf{R}_{++}$. Substituting in the graph implementation of $f$, our problem can be rewritten as
$$
  \begin{array}{ll}
    \mbox{minimize} & t \\
    \mbox{subject to} & Ax = b,  \quad (x,y) \in \mathbf{dom}\;f, \quad \left(\begin{pmatrix} y-t \\ 2x \end{pmatrix}, y+t\right) \in \mathcal{K},
  \end{array}
$$
where $t \in \mathbf{R}$ is the additional graph variable. If $b \in \mathbf{null}\;A$, the solution is trivially $x^* = \vec{0}$ and any $y^* > 0$. Otherwise, the point $y = 0$ is infeasible, so we can relax the domain constraint to get
$$
    \begin{array}{ll}
    \mbox{minimize} & t \\
    \mbox{subject to} & Ax = b, \quad y \geq 0, \quad \left(\begin{pmatrix} y-t \\ 2x \end{pmatrix}, y+t\right) \in \mathcal{K}.
  \end{array}
$$
This SOCP canonicalization may then be passed into a cone solver to obtain the optimal $t^* = f(x^*,y^*)$. TODO: A few words on how CVXR does this automatically with the canonicalization of the atom.

